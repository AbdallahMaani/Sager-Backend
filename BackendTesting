

namespace Bus_ticketing_Backend.DTOs
{
// Returned to client (NO sensitive data)
// DTO is similiar to Fire wall, it prevents sensitive data from being exposed to the client.
//DTOs belonge to the Controller (API Layer) they contrect for what the frontend see
//Repository belongs to the Data Layer and entities
public class UserDTOs
{
public Guid UserId { get; set; }
public string Username { get; set; }
public string FullName { get; set; }
public string Email { get; set; }
public string Phone { get; set; }
public string Role { get; set; }
public decimal Balance { get; set; }
}

public class RegisterDto  
{  
    public string Username { get; set; }  
    public string FullName { get; set; }  
    public string Email { get; set; }  
    public string Password { get; set; }  
    public string Phone { get; set; }  
}  

public class UpdateUserDTO   
{   
    public string FullName { get; set; }  
    public string Email { get; set; }  
    public string Phone { get; set; }  
}  

public class LoginDto  
{  
    public string Username { get; set; }  
    public string Password { get; set; }  
}  

public class RefreshTokenDto  
{  
    // UserId and RefreshToken will come from the cookie  
}  

public class TokenResponseDto  
{  
    public string AccessToken { get; set; }  
}  

public class ChangePasswordDto  
{  
    public string OldPassword { get; set; }  
    public string NewPassword { get; set; }  
}  

public class AdminResetPasswordDto  
{  
    public string NewPassword { get; set; }  
}

}
using Bus_ticketing_Backend.IRepositories;
using Bus_ticketing_Backend.Data;
using Bus_ticketingAPI.Entities;
using Microsoft.EntityFrameworkCore;

namespace Bus_ticketing_Backend.Repositories
{
public class UserRepository : IUserRepository
{
private readonly AppDbContext _context;
public UserRepository(AppDbContext context) => _context = context;

public async Task<IEnumerable<User>> GetAllUsersAsync() =>   
        await _context.Users.AsNoTracking().ToListAsync();  

    public async Task<User?> GetUserByIdAsync(Guid userId) =>  
        await _context.Users.FindAsync(userId);  

    public async Task<User?> GetByUsernameAsync(string username) =>  
        await _context.Users.FirstOrDefaultAsync(u => u.Username == username);  

    public async Task AddUserAsync(User user)  
   {  
        await _context.Users.AddAsync(user);  
        await _context.SaveChangesAsync();  
    }  

    public async Task UpdateUserAsync(User user)  
    {  
        _context.Users.Update(user);  
        await _context.SaveChangesAsync();  
    }  

    public async Task<bool> AddBalanceAsync(Guid userId, decimal amount)  
    {  
        var user = await _context.Users.FindAsync(userId);  
        if (user == null) return false;  

        user.Balance += amount;  
        await _context.SaveChangesAsync();  
        return true;  
    }  

    public async Task DeleteUserAsync(Guid userId)  
    {  
        var user = await _context.Users.FindAsync(userId);  
        if (user != null)  
        {  
            _context.Users.Remove(user);  
            await _context.SaveChangesAsync();  
        }  
    }  

    public async Task<User?> GetUserByRefreshTokenAsync(string refreshToken)  
    {  
        return await _context.Users  
            .FirstOrDefaultAsync(u =>  
                u.RefreshToken == refreshToken &&  
                u.RefreshTokenExpiryTime > DateTime.UtcNow);  
    }  

}

}
// Use AsNoTracking for read-only lists to improve speed .
//We use AsNoTracking() because you're not editing them in that moment.
using Bus_ticketing_Backend.DTOs;
using Bus_ticketing_Backend.IRepositories;
using Bus_ticketing_Backend.Services;
using Bus_ticketingAPI.Entities;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;

namespace Bus_ticketing_Backend.Controllers
{
[Route("api/[controller]")]

[ApiController]   
public class UserController : ControllerBase   
{  
    private readonly IUserRepository _userRepository;  
    private readonly IAuthService _authService;  

    public UserController(IUserRepository repository, IAuthService authService)  
    {  
        _userRepository = repository;  
        _authService = authService;  
    }  

    [Authorize(Roles = "Admin")]  
    [HttpGet]  
    public async Task<ActionResult<IEnumerable<UserDTOs>>> GetAll()  
    {  
        var users = await _userRepository.GetAllUsersAsync();  
        var result = users.Select(MapToDto); //select : Projects each element of a list into a new form.  
        return Ok(result);  
    }  

    [Authorize]  
    [HttpGet("me")]  
    public async Task<ActionResult<UserDTOs>> GetMyProfile()  
    {  
        var userId = GetCurrentUserId();  
        if (userId == Guid.Empty) return Unauthorized();  

        var user = await _userRepository.GetUserByIdAsync(userId);  
        if (user == null) return NotFound();  

        return Ok(MapToDto(user)); //// 200 OK + user data Wrap it in an HTTP 200 OK response  
    }  

    [Authorize]  
    [HttpGet("{id:Guid}")]  
    public async Task<ActionResult<UserDTOs>> GetById([FromRoute] Guid id) //Task means the method is asynchronous and will return a result in the future.  
                                                                           // ActionResult is a wrapper that lets you return different HTTP responses:  
    {  
        var user = await _userRepository.GetUserByIdAsync(id);  
        if (user == null) return NotFound();  

        var currentUserId = GetCurrentUserId();  
        if (!User.IsInRole("Admin") && currentUserId != id)  
        {  
            return Forbid();  
        }  
        return Ok(MapToDto(user));  
    }  

    [Authorize]  
    [HttpPut("{id:Guid}")]  
    public async Task<ActionResult> Update([FromRoute] Guid id, UpdateUserDTO dto)   
        // [FromRoute] Guid id : get the user id from the route parameter not from the request body  
    {  
        var currentUserId = GetCurrentUserId();  
        if (!User.IsInRole("Admin") && currentUserId != id)  
            return Forbid();  

        var user = await _userRepository.GetUserByIdAsync(id);  
        if (user == null) return NotFound();  

        user.FullName = dto.FullName;  
        user.Phone = dto.Phone;  
        user.Email = dto.Email;  
          
        await _userRepository.UpdateUserAsync(user);  
        return NoContent();  
    }  

    [Authorize]  
    [HttpDelete("{id:Guid}")]  
    public async Task<ActionResult> Delete([FromRoute] Guid id)  
    {  
        var currentUserId = GetCurrentUserId();  
        if (!User.IsInRole("Admin") && currentUserId != id)  
            return Forbid();  

        await _userRepository.DeleteUserAsync(id);  
        return NoContent();  
    }  

      
    [Authorize]  
    [HttpPost("topup")]  
    public async Task<IActionResult> TopUp([FromBody] decimal amount)  
    {  
        if (amount <= 0) return BadRequest("Amount must be greater than zero.");  

        var userId = GetCurrentUserId();  

        var success = await _userRepository.AddBalanceAsync(userId, amount);  

        if (!success) return BadRequest("User not found.");  

        return Ok(new { message = "Balance updated successfully." });  
    }  

    [HttpPost("register")]  
    public async Task<ActionResult<UserDTOs>> Register(RegisterDto dto)  
    {  
        var user = await _authService.RegisterAsync(dto);  
        if (user == null) return BadRequest("Username already exists.");  
        return Ok(MapToDto(user));

//  1.MapToDto(user) - Convert User entity to UserDTOs 2.Ok(...) - Wrap it in an HTTP 200 OK response 3.  return -Send to frontend
}

[HttpPost("login")]  
    public async Task<ActionResult<TokenResponseDto>> Login(LoginDto dto)  
    {  
        var result = await _authService.LoginAsync(dto);  
        if (result == null) return BadRequest("Invalid username or password.");  
          
        // Get the user to access refresh token  
        var user = await _userRepository.GetByUsernameAsync(dto.Username);  
        if (user?.RefreshToken != null)  
        {  
            SetRefreshTokenCookie(user.RefreshToken);  
        }  
          
        return Ok(result);  
    }  

    [HttpPost("refresh-token")]  
    public async Task<ActionResult<TokenResponseDto>> RefreshToken()  
    {  
        var refreshToken = Request.Cookies["refreshToken"];  
        if (string.IsNullOrEmpty(refreshToken))  
            return Unauthorized();  

        var result = await _authService.RefreshTokensAsync(refreshToken);  
        if (result == null)  
            return Unauthorized();  

        // refresh token rotated → cookie updated  
        var user = await _userRepository.GetUserByRefreshTokenAsync(refreshToken);  
        SetRefreshTokenCookie(user!.RefreshToken!);  

        return Ok(result);  
    }  



    // Helper method to set HTTP-only cookie  
    private void SetRefreshTokenCookie(string refreshToken)  
    {  
        var cookieOptions = new CookieOptions  
        {  
            HttpOnly = true,  
            Secure = false, // Only sent over HTTPS  
            SameSite = SameSiteMode.Lax,  
            Expires = DateTimeOffset.UtcNow.AddDays(7)  
        };  

        Response.Cookies.Append("refreshToken", refreshToken, cookieOptions);  
    }  

    //Helper get Id from JWT  
    private Guid GetCurrentUserId()  
    {  
        var claim = User.FindFirstValue(ClaimTypes.NameIdentifier);  
        return Guid.TryParse(claim, out var id) ? id : Guid.Empty;  
    }  

    private static UserDTOs MapToDto(User u) => new UserDTOs  
    {  
        UserId = u.UserId,  
        Username = u.Username,  
        FullName = u.FullName,  
        Email = u.Email,  
        Phone = u.Phone,  
        Role = u.Role,  
        Balance = u.Balance  
    };  

    [Authorize]  
    [HttpPost("change-password")]  
    public async Task<IActionResult> ChangePassword([FromBody] ChangePasswordDto dto)  
    {  
        if (string.IsNullOrWhiteSpace(dto.OldPassword) || string.IsNullOrWhiteSpace(dto.NewPassword))  
            return BadRequest("Both old and new passwords are required.");  

        var userId = GetCurrentUserId();  
        if (userId == Guid.Empty)  
            return Unauthorized();  

        var success = await _authService.ChangePasswordAsync(userId, dto);  

        if (!success)  
            return BadRequest("Failed to change password. Old password may be incorrect.");  

        return Ok(new { message = "Password changed successfully." });  
    }  

    [Authorize(Roles = "Admin")]  
    [HttpPost("{id:Guid}/reset-password")]  
    public async Task<ActionResult> AdminResetPassword([FromRoute] Guid id, [FromBody] AdminResetPasswordDto dto)  
    {  
        // Admin doesn't need to know the old password  
        var result = await _authService.ForceResetPasswordAsync(id, dto.NewPassword);  

        if (!result)  
            return NotFound("User not found.");  

        return Ok(new { message = "Password has been reset by Admin." });  
    }  

    [Authorize]  
    [HttpPost("logout")]  
    public IActionResult Logout()  
    {  
        Response.Cookies.Delete("refreshToken");  
        return Ok(new { message = "Logged out successfully." });  
    }  
}

}

/*

What is ActionResult?
ActionResult is a wrapper that lets you return different HTTP responses:


return Ok(user);              // 200 OK + user data
return NotFound();            // 404 Not Found
return BadRequest("error");   // 400 Bad Request
return Unauthorized();        // 401 Unauthorized
return Forbid();              // 403 Forbidden
return NoContent();           // 204 No Content

var result = users.Select(MapToDto);
Select :
Projects each element of a list into a new form.
users = [User1, User2, User3]
↓
Select(MapToDto)
↓
result = [UserDTO1, UserDTO2, UserDTO3]

[Route("api/[controller]")] this line defines the base route for all endpoints in this controller.  
                             [Controller] will be replaced by the controller's name ,so in this case, it becomes "api/user".  
[ApiController]  This attribute indicates that the class is an API controller.  
public class UserController : ControllerBase  Inherits from ControllerBase to provide basic functionalities for handling HTTP requests.

*/

using Bus_ticketing_Backend.DTOs;
using Bus_ticketing_Backend.IRepositories;
using Bus_ticketingAPI.Entities;
using Microsoft.AspNetCore.Identity;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;

namespace Bus_ticketing_Backend.Services
{
public class AuthService : IAuthService
{
private readonly IUserRepository _userReposiotry;
private readonly IConfiguration _config;
// what is IConfiguration? it's used to access configuration settings in .NET applications.

public AuthService(IUserRepository repo, IConfiguration config)  
    {  
        _userReposiotry = repo;  
        _config = config;  
    }  

    public async Task<User?> RegisterAsync(RegisterDto dto)  
    {  
        var existingUser = await _userReposiotry.GetByUsernameAsync(dto.Username);   
        if (existingUser != null)   
            return null;  

        var user = new User  
        {  
            UserId = Guid.NewGuid(),   
            Username = dto.Username,  
            FullName = dto.FullName,  
            Email = dto.Email,  
            Phone = dto.Phone,  
            Role = "customer",  
            Balance = 0  
        };  

        user.PasswordHash = new PasswordHasher<User>()  
            .HashPassword(user, dto.Password);  

        await _userReposiotry.AddUserAsync(user);  
        return user;  
    }  

    public async Task<TokenResponseDto?> LoginAsync(LoginDto dto)  
    {  
        var user = await _userReposiotry.GetByUsernameAsync(dto.Username);  
        if (user == null) return null;  

        var result = new PasswordHasher<User>()  
            .VerifyHashedPassword(user, user.PasswordHash, dto.Password);  

        if (result == PasswordVerificationResult.Failed)  
            return null;  

        return await CreateTokenResponse(user);  
    }  

    private async Task<TokenResponseDto> CreateTokenResponse(User user)  
    {  
        var accessToken = CreateJwt(user);  
        var refreshToken = await GenerateRefreshTokenOnlyAsync(user);  
          
        // Store refresh token for use in controller to set cookie  
        // We'll pass this via a different mechanism (see Step 4)  
        return new TokenResponseDto  
        {  
            AccessToken = accessToken  
        };  
    }  

    private string CreateJwt(User user)  
    {  
        var claims = new List<Claim>  
        {  
            new Claim(ClaimTypes.NameIdentifier, user.UserId.ToString()),  
            new Claim(ClaimTypes.Name, user.Username),  
            new Claim(ClaimTypes.Role, user.Role)  
        };  

        var key = new SymmetricSecurityKey(  
            Encoding.UTF8.GetBytes(_config["Jwt:Key"]!));  

        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha512);  

        var token = new JwtSecurityToken(  
            issuer: _config["Jwt:Issuer"],  
            audience: _config["Jwt:Audience"],  
            claims: claims,  
            expires: DateTime.UtcNow.AddMinutes(15),  
            signingCredentials: creds  
        );  

        return new JwtSecurityTokenHandler().WriteToken(token);  
    }  

    public async Task<string> GenerateRefreshTokenOnlyAsync(User user)  
    {  
        var randomNumber = new byte[32];  
        using var rng = RandomNumberGenerator.Create();  
        rng.GetBytes(randomNumber);  
        var refreshToken = Convert.ToBase64String(randomNumber);  

        user.RefreshToken = refreshToken;  
        user.RefreshTokenExpiryTime = DateTime.UtcNow.AddDays(7);  

        await _userReposiotry.UpdateUserAsync(user);  
        return refreshToken;  
    }  

    public async Task<TokenResponseDto?> RefreshTokensAsync(string refreshToken)  
    {  
        var user = await _userReposiotry.GetUserByRefreshTokenAsync(refreshToken);  

        if (user == null || user.RefreshTokenExpiryTime <= DateTime.UtcNow)  
            return null;  

        return await CreateTokenResponse(user);  
    }  

    public async Task<bool> ChangePasswordAsync(Guid userId, ChangePasswordDto request)  
    {  

        if (string.IsNullOrWhiteSpace(request.OldPassword) || string.IsNullOrWhiteSpace(request.NewPassword))  
            return false;  

        var user = await _userReposiotry.GetUserByIdAsync(userId);  
        if (user == null)  
            return false;  

        var passwordHasher = new PasswordHasher<User>();  
        var result = passwordHasher.VerifyHashedPassword(user, user.PasswordHash, request.OldPassword);  

        if (result == PasswordVerificationResult.Failed)  
            return false;  

        user.PasswordHash = passwordHasher.HashPassword(user, request.NewPassword);  
        await _userReposiotry.UpdateUserAsync(user);  

        return true;  
    }  

    public async Task<bool> ForceResetPasswordAsync(Guid userId, string newPassword)  
    {  
        var user = await _userReposiotry.GetUserByIdAsync(userId);  
        if (user == null) return false;  

        // No Old Password check needed for Admin  

        var passwordHasher = new PasswordHasher<User>();  
        user.PasswordHash = passwordHasher.HashPassword(user, newPassword);  

        await _userReposiotry.UpdateUserAsync(user);  

        return true;  
    }  
}

}
بشكل موضح ركز على الcontroller and authservice
واحكيلي شو ال packages and libraries المستخدمين اذا موجود اشي  ?